using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Maze
{
    /// <summary>
    /// Generates a Maze using a spiral path algorithm.
    /// The maze is represented as a grid of MazeNode objects, each of which can have walls in four directions.
    /// The maze is generated by initializing nodes, setting their orientations.
    /// The maze can be shuffled at runtime, allowing for dynamic changes to the maze structure.
    /// </summary>
    public class MazeGenerator : MonoBehaviour
    {
        [Header("Maze Generation Settings")]
        [SerializeField] private Vector2Int origin = new Vector2Int(0, 0);
        [SerializeField] public int MazeWidth = 10;
        [SerializeField] public int MazeHeight = 10;
        [Tooltip("Maximum size of the maze. If the maze exceeds this size, it may cause performance issues. This will not prevent the maze from being generated.")]
        [SerializeField] private int MazeDangerousSizeLimit = 10000;
        
        [Header("Maze Node Settings")]
        [Tooltip("Prefab for the MazeNode. This should contain a MazeNode component that handles the node's behavior and rendering.")]
        [SerializeField] private GameObject nodePrefab;
        [Tooltip("Size of each cell in the maze. This affects the spacing between nodes. Set it to the same value as the ChunkCell size for proper alignment.")]
        [SerializeField] private int nodeMeshSize = 5;

        [Header("Initial Shuffle Settings")]
        [Tooltip("Initial shuffle factor to determine how many jumps to perform during the initial shuffle. Higher values increase complexity.")]
        [SerializeField] private int initialShuffleFactor = 10;

        [Header("Runtime shuffle Settings")]
        [Tooltip("Time interval between jumps in seconds. Set to 0 for immediate jumps.")]
        [SerializeField] private float intervalSeconds = 2f;
        [SerializeField] private bool enableRuntimeShuffle = true;
        [Tooltip("Number of steps to shuffle the maze at runtime. Higher values increase complexity & time.")]
        [SerializeField] private int runtimeShuffleSteps = 20;

        /// <summary>
        /// Dictionary to map node directions to angles.
        /// </summary>
        private Dictionary<string, int> nodeDirections = new Dictionary<string, int>
        {
            { "down", 270 },
            { "right", 180 },
            { "up", 90 },
            { "left", 0 }
        };

        /// <summary>
        /// Dictionary to map angles to their respective modifications in the maze node matrix.
        /// </summary>
        private Dictionary<int, int> nodeAngleMatriceModificator = new Dictionary<int, int>
        {
            { -1, 0},
            { 0, 1},
            { 90, 1},
            { 180, -1},
            { 270, -1}
        };

        private string[] _nodeDirectionsList = new string[] { "down", "right", "up", "left" };

        /// <summary>
        /// Timer to control the interval for runtime shuffling.
        /// </summary>
        private float timer;

        /// <summary>
        /// 2D array of MazeNode objects representing the maze.
        /// </summary>
        private MazeNode[,] mazeNodes;

        /// <summary>
        /// Sets the current origin of the maze.
        /// </summary>
        public void SetOrigin(int x, int z)
        {
            origin = new Vector2Int(x, z);
        }

        /// <summary>
        /// Gets a random direction from the available directions based on the current origin position.
        /// The available directions are determined by the boundaries of the maze.
        /// If the origin is at the edge of the maze, it will not include directions that would go out of bounds.
        /// </summary>
        /// <returns>String[up,right,down,left]</returns>
        string GetAvailableRandomDirection()
        {
            List<string> directions = new();

            if (origin.x > 0) directions.Add("right");
            if (origin.y > 0) directions.Add("down");
            if (origin.x < MazeWidth - 1) directions.Add("left");
            if (origin.y < MazeHeight - 1) directions.Add("up");

            return directions[Random.Range(0, directions.Count)];
        }


        void PerformOriginJump()
        {
            // Get a random jump direction
            int angle = nodeDirections[GetAvailableRandomDirection()];

            // Set the direction of the current node to the jump direction
            mazeNodes[origin.x, origin.y].SetNodeDirection(angle);

            // Move the origin in the specified direction
            if (angle == 0 || angle == 180)
            {
                origin.x = Mathf.Clamp(origin.x + nodeAngleMatriceModificator[angle], 0, MazeWidth - 1);
            }
            else if (angle == 90 || angle == 270)
            {
                origin.y = Mathf.Clamp(origin.y + nodeAngleMatriceModificator[angle], 0, MazeHeight - 1);
            }

            // Update the origin node's direction
            mazeNodes[origin.x, origin.y].SetNodeDirection(-1);
        }

        void Awake()
        {
            if (MazeWidth * MazeHeight >= MazeDangerousSizeLimit)
            {
                Debug.LogWarning($"Maze size ({MazeWidth}x{MazeHeight}) exceeds the dangerous limit of {MazeDangerousSizeLimit}. This may cause performance issues.");
            }

            // Instantiate the maze nodes
            SpawnNodes();

            // Initialize the maze nodes' orientations
            InitializeNodeOrientation();

            // First shuffle of the maze to create a randomized structure
            InitialShuffle();

            // Instantiate MazeNode meshes
            RenderMaze();
        }

        /// <summary>
        /// Updates the maze at runtime based on the specified interval.
        /// If runtime shuffling is enabled, it will shuffle the maze nodes at the specified interval.
        /// </summary>
        void Update()
        {
            if (enableRuntimeShuffle)
            {
                timer += Time.deltaTime;
                if (timer >= intervalSeconds)
                {
                    timer -= intervalSeconds; // preserves leftover time
                    RuntimeShuffle();
                    RenderMaze();
                }
            }
        }

        /// <summary>
        /// Spawns MazeNode objects in a grid layout based on the specified MazeWidth and MazeHeight.
        /// Each node is instantiated at a position determined by the cellSize and its coordinates in the grid.
        /// By default, the nodes orientation is set to -1 (no direction).
        /// </summary>
        public void SpawnNodes()
        {
            mazeNodes = new MazeNode[MazeWidth, MazeHeight];

            for (int x = 0; x < MazeWidth; x++)
            {
                for (int z = 0; z < MazeHeight; z++)
                {
                    Vector3 position = new Vector3(nodeMeshSize * x, 0, nodeMeshSize * z);
                    GameObject nodeObject = Instantiate(nodePrefab, position, Quaternion.identity, transform);
                    MazeNode node = nodeObject.GetComponent<MazeNode>();
                    if (node != null)
                    {
                        mazeNodes[x, z] = node;
                        node.SetMazePosition(x, z);
                    }
                }
            }
        }

        /// <summary>
        /// Initializes the orientation of each MazeNode in a spiral path.
        /// The spiral path starts from the top-left corner and moves inward.
        /// </summary>
        public void InitializeNodeOrientation()
        {
            List<Vector2Int> spiralPath = new List<Vector2Int>();

            int top = 0, bottom = MazeHeight - 1;
            int left = 0, right = MazeWidth - 1;

            while (left <= right && top <= bottom)
            {
                for (int z = top; z <= bottom; z++)
                    spiralPath.Add(new Vector2Int(left, z));
                left++;

                for (int x = left; x <= right; x++)
                    spiralPath.Add(new Vector2Int(x, bottom));
                bottom--;

                for (int z = bottom; z >= top; z--)
                    spiralPath.Add(new Vector2Int(right, z));
                right--;

                for (int x = right; x >= left; x--)
                    spiralPath.Add(new Vector2Int(x, top));
                top++;
            }

            // Set each node to point toward the next node
            for (int i = 0; i < spiralPath.Count - 1; i++)
            {
                Vector2Int current = spiralPath[i];
                Vector2Int next = spiralPath[i + 1];

                Vector3 dir = mazeNodes[next.x, next.y].GetPosition() - mazeNodes[current.x, current.y].GetPosition();
                float angle = Mathf.Atan2(dir.z, dir.x) * Mathf.Rad2Deg;

                // Normalize to 0, 90, 180, 270
                angle = Mathf.Round(angle / 90f) * 90f;
                if (angle < 0) angle += 360f;
                mazeNodes[current.x, current.y].SetNodeDirection(angle);
            }

            // Set the last node's direction to -1 and set it as the origin
            Vector2Int last = spiralPath[spiralPath.Count - 1];
            mazeNodes[last.x, last.y].SetNodeDirection(-1);
            SetOrigin(last.x, last.y);
        }

        /// <summary>
        /// Initializes the maze by performing a series of jumps from the origin node.
        /// The number of jumps is determined by the size of the maze (MazeWidth * MazeHeight) multiplied by a constant factor.
        /// </summary>
        public void InitialShuffle()
        {
            int initialShuffleCount = MazeWidth * MazeHeight * initialShuffleFactor;
            for (int i = 0; i < initialShuffleCount; i++)
            {
                PerformOriginJump();
            }
        }

        /// <summary>
        /// Renders the maze by iterating through each MazeNode in the mazeNodes array.
        /// This instantiates a MazeWith x MazeHeight MazeNode meshes at their respective positions.
        /// </summary>
        void RenderMaze()
        {
            for (int x = 0; x < MazeWidth; x++)
            {
                for (int z = 0; z < MazeHeight; z++)
                {
                    if (mazeNodes[x, z] != null)
                    {
                        mazeNodes[x, z].Render(GetTargettingNode(x, z));
                    }
                }
            }
        }

        /// <summary>
        /// Gets the targetting MazeNode based on the current node's direction.
        /// </summary>
        /// <param name="x">Current node matrice X pos</param>
        /// <param name="z">Current node matrice Z/Y pos</param>
        /// <returns>Nodes faced by the selected one.</returns>
        /// <exception cref="System.Exception">Throw an exception if the node at x,z coord does not exists.</exception>
        private MazeNode GetTargettingNode(int x, int z)
        {
            int angle = (int)mazeNodes[x, z]?.GetNodeDirection();
            if (angle == 0 || angle == 180)
            {
                return mazeNodes[x + nodeAngleMatriceModificator[angle], z] ?? throw new System.Exception($"MazeNode at ({x + nodeAngleMatriceModificator[angle]}, {z}) is null. Ensure nodes are spawned correctly.");
            }
            else if (angle == 90 || angle == 270)
            {
                return mazeNodes[x, z + nodeAngleMatriceModificator[angle]] ?? throw new System.Exception($"MazeNode at ({x}, {z + nodeAngleMatriceModificator[angle]}) is null. Ensure nodes are spawned correctly.");
            }
            return mazeNodes[x, z] ?? throw new System.Exception($"MazeNode at ({x}, {z}) is null. Ensure nodes are spawned correctly.");
        }

        /// <summary>
        /// Shuffles the maze at runtime by resetting the walls of each MazeNode and performing a series of jumps.
        /// The number of jumps is determined by the MazeWidth * MazeHeight multiplied by the runtimeShuffleSteps.
        /// </summary>
        /// <remarks>
        /// This method resets the direction of each MazeNode to -1 before performing the jumps.
        /// It allows for dynamic changes to the maze structure during gameplay.
        /// </remarks>
        public void RuntimeShuffle()
        {
            for (int x = 0; x < MazeWidth; x++)
            {
                for (int z = 0; z < MazeHeight; z++)
                {
                    if (mazeNodes[x, z] != null)
                    {
                        mazeNodes[x, z].ResetWalls(); // Reset direction to -1
                    }
                }
            }

            int runtimeShuffleCount = MazeWidth * MazeHeight * runtimeShuffleSteps;
            for (int i = 0; i < runtimeShuffleCount; i++)
            {
                PerformOriginJump();
            }
        }
    }
}